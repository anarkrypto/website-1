# Structure

In Protokit, the primary way to build application is through **runtime modules**.
You can think of them like solidity `contract` objects.
They basically are a unit of scope which can hold state, functions and call other runtime modules.

## Runtime modules

Runtime modules are Typescript classes, decorated with `@runtimeModule()` and extending `RuntimeModule` to enable protokit to do magic behind the scenes.

```ts
@runtimeModule()
export class ExampleModule extends RuntimeModule<...> {

  // Define some provable state for your module

  // Define some functions
  @runtimeMethod()
  public foo() {
      ...
  }
}
```

In the next sections, we will go through state, functions, composability and more. to give you a good overview on how to write runtime modules.




### Functions

Functions define some computation of something we call a "state transition".
This means, that all functions transform your applications state *from* something, *to* something.
This is no different that regular functions in other programming models.

All functions that are part of a module and `public`, are by default callable by your user's transactions.

Functions can have different properties and offer a lot of possibilities, more on that in [Writing functions](/docs/basics/functions)




















```ts
@runtimeModule()
export class TokenModule extends RuntimeModule<...> {

  // Define some provable state for your module
  @state() public totalSupply = State.from<UInt64>(UInt64);

  // Define some functions
  @runtimeMethod()
  public setTotalSupply() {
    this.totalSupply.set(UInt64.from(20));
  }
}
```