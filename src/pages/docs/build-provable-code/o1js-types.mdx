# o1js data types and composite types

Retrieved from [docs.minaprotocol.com](https://docs.minaprotocol.com/zkapps/o1js/basic-concepts)

### Field

Field elements are the basic unit of data in zero-knowledge proof programming. Each field element can store a number up to almost 256 bits in size. You can think of it as a uint256 in Solidity.

For example, in typical programming, you might use:

`const sum = 1 + 3`

In o1js, you write this as:

`const sum = new Field(1).add(new Field(3))`

This can be simplified as:

`const sum = new Field(1).add(3)`

Note that the 3 is auto-promoted to a field type to make this cleaner.

### Built-in data types

Some common data types you may use are:

```ts
new Bool(x);   // accepts true or false
new Field(x);  // accepts an integer, or a numeric string if you want to represent a number greater than JavaScript can represent but within the max value that a field can store.
new UInt64(x); // accepts a Field - useful for constraining numbers to 64 bits
new UInt32(x); // accepts a Field - useful for constraining numbers to 32 bits

PrivateKey, PublicKey, Signature; // useful for accounts and signing
new Group(x, y); // a point on our elliptic curve, accepts two Fields/numbers/strings
Scalar; // the corresponding scalar field (different than Field)

CircuitString.from('some string'); // string of max length 128
```

In the case of Field and Bool, you can also call the constructor without new:

```ts
let x = Field(10);
let b = Bool(true);
```

### Conditionals

Traditional conditional statements are not supported by o1js:

```ts
// this will NOT work
if (foo) {
  x.assertEquals(y);
}
```

Instead, use the o1js built-in Circuit.if() method, which is a ternary operator:

```ts
const x = Circuit.if(new Bool(foo), a, b); // behaves like `foo ? a : b`
```

...