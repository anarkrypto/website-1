# Usage of patterns inside circuits

### Loops

We already established that all code that we execute must be static and have the exact same execution steps with every possible input.
That also means that **dynamic sized loops are not possible**.
However, there are some exceptions and patterns we can still use.

Specifically, fixed bounded loops. That means that we can create loops as long as the loop always runs the exact same amount of iterations.

The first pattern can be used pretty safely:
```ts
for(const i = 0 ; i < 5 ; i++){
    // Provable code
}
```

One has to be a bit more careful with the second pattern though:

```ts
// Precondition: inputs.length is constant
function foo(inputs: Field[]){
    for(const input of inputs){
        // Provable code
    }
}
```
The developer has to make sure that the length of `inputs` stays the same for every invocation.
A failure to do so will result in something we call "compiler/prover discrepancies", where the circuit we are trying to prove is a different one from the originally compiled one.
This will throw obscure errors way down the stack, so it's better not to run into these issues.

Logically, correct usage of this pattern also enables usage of methods like `forEach`, `map`, `reduce`, etc.